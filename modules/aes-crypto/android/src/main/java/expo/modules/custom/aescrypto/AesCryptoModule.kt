package expo.modules.custom.aescrypto

import android.util.Base64
import expo.modules.core.errors.CodedException
import expo.modules.kotlin.apifeatures.EitherType
import expo.modules.kotlin.exception.Exceptions
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import expo.modules.kotlin.records.Field
import expo.modules.kotlin.records.Record
import expo.modules.kotlin.types.Either
import expo.modules.kotlin.types.Enumerable
import java.nio.ByteBuffer
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.contract
import kotlin.reflect.KClass

private const val ALGORITHM_AES = "AES"
private const val CIPHER_TRANSFORMATION_NAME = "AES/GCM/NoPadding"
private const val IV_LENGTH = 12 // bytes - unique Initialization Vector (nonce)
private const val TAG_LENGTH = 16 // bytes - GCM auth tag

// https://discuss.kotlinlang.org/t/proposal-this-type-for-generics-can-kotlin-interface-detects-on-which-class-is-attached-to-on-its-own/26321/4
// https://medium.com/@jerzy.chalupski/emulating-self-types-in-kotlin-d64fe8ea2e62
interface DefaultEnumValue<Self: Enumerable> {
  fun defaultValue(): Self
}

//fun <T: EnumWithDefault<T>> T.default(): T = defaultValue()

private const val DEFAULT_IV_LENGTH: Int = 12
private const val DEFAULT_TAG_LENGTH: Int = 16

enum class DataEncoding(value: String): Enumerable {
  BASE64("base64"),
  HEX("hex")
}

enum class OutputFormat(value: String): Enumerable {
  BYTES("bytes"),
  BASE64("base64");
}

data class SealedDataConfig(
  @Field val ivLength: Int = DEFAULT_IV_LENGTH,
  @Field val tagLength: Int = DEFAULT_TAG_LENGTH
): Record

data class CiphertextOptions(
  @Field val includeTag: Boolean = false,
  @Field val outputFormat: OutputFormat = OutputFormat.BYTES
): Record

@OptIn(EitherType::class)
class EncryptOptions: Record {
  // TODO: In JS this is a nested Record
  @Field val nonce: Either<ByteArray, Int>? = null
  @Field val tagLength: Int? = null
  @Field val additionalData: ByteArray? = null

  internal fun gcmParameterSpec(random: SecureRandom): GCMParameterSpec? {
    // a default will be generated by Cipher
    if (nonce == null && tagLength == null) {
      return null
    }

    val iv = when (nonce.getType()) {
      ByteArray::class -> nonce.get(ByteArray::class)
      Int::class -> ByteArray(nonce.get(Int::class)).also { random.nextBytes(it) }
      else -> ByteArray(DEFAULT_IV_LENGTH).also { random.nextBytes(it) }
    }

    return GCMParameterSpec(tagLength ?: DEFAULT_TAG_LENGTH, iv)
  }
}

@OptIn(EitherType::class)
class DecryptOptions: Record {
  @Field val output: OutputFormat = OutputFormat.BYTES
  @Field val additionalData: ByteArray? = null
}

class AesCryptoModule : Module() {
  private val rng: SecureRandom by lazy { SecureRandom() }

  @OptIn(EitherType::class)
  override fun definition() = ModuleDefinition {
    Name("AesCrypto")

    AsyncFunction("generateKey", this@AesCryptoModule::generateKey)
    AsyncFunction("importKey", this@AesCryptoModule::importKey)

    AsyncFunction("encryptAsync", this@AesCryptoModule::encrypt)
    AsyncFunction("decryptAsync", this@AesCryptoModule::decrypt)

    Class("EncryptionKey", EncryptionKey::class) {
      Constructor { size: KeySize -> EncryptionKey(size) }

      Property("size") { key: EncryptionKey -> key.keySize }

      AsyncFunction("bytes") { key: EncryptionKey -> key.bytes }
      AsyncFunction("encoded") { key: EncryptionKey, encoding: DataEncoding ->
        key.bytes.encoded(encoding)
      }
    }

    Class("SealedData", SealedData::class) {
      Constructor {
        throw Exceptions.IllegalArgument("SealedData constructor cannot be used directly")
      }
      StaticFunction("fromNonceAndCiphertext") { iv: ByteArray, ciphertext: ByteArray, tag: Either<ByteArray, Int>? ->
//        when (tag.getType()) {
//          Int::class -> {
//            val tagLength = tag.get(Int::class)
//            SealedData(iv, ciphertext, tagLength)
//          }
//          ByteArray::class -> {
//            val tag = tag.get(ByteArray::class)
//            SealedData(iv, ciphertext + tag, tag.size)
//          }
//          else -> SealedData(iv, ciphertext, DEFAULT_TAG_LENGTH)
//        }

        val tagSealed = tag.getSealed()
        when (tagSealed) {
          is EitherValue.First -> {
            val tagBytes = tagSealed.value
            SealedData(iv, ciphertext + tagBytes, tagBytes.size)
          }
          is EitherValue.Second -> {
            val tagLength = tagSealed.value
            SealedData(iv, ciphertext, tagLength)

          }
          else -> SealedData(iv, ciphertext, DEFAULT_TAG_LENGTH)
        }

//        if (tag?.`is`(Int::class) == true) {
//          val tagLength = tag.get(Int::class)
//          SealedData(iv, ciphertext, tagLength)
//        } else if (tag?.`is`(ByteArray::class) == true) {
//          val tag = tag.get(ByteArray::class)
//          SealedData(iv, ciphertext + tag, tag.size)
//        } else {
//          return@StaticFunction SealedData(iv, ciphertext, DEFAULT_TAG_LENGTH)
//        }
      }
      StaticFunction("fromCombined") { combined: ByteArray, config: SealedDataConfig?  ->
        val config = config ?: SealedDataConfig()
        SealedData(config, content = combined)
      }

      Property("combinedSize") { sealedData -> sealedData.combinedBuffer.remaining() }
      Property("ivSize") { sealedData -> sealedData.ivLength }
      Property("tagSize") { sealedData -> sealedData.tagLength }

      AsyncFunction("iv") { sealedData: SealedData, format: OutputFormat? ->
        sealedData.ivBytes.formatted(format)
      }
      AsyncFunction("tag") { sealedData: SealedData, format: OutputFormat? ->
        sealedData.tagBuffer.copiedArray().formatted(format)
      }
      AsyncFunction("combined") { sealedData: SealedData, format: OutputFormat? ->
        sealedData.combinedBuffer.array().formatted(format)
      }
      AsyncFunction("ciphertext") { sealedData: SealedData, options: CiphertextOptions? ->
        val (includeTag, outputFormat) = options ?: CiphertextOptions()
        val buffer = if (includeTag) {
          sealedData.nativeCipherBuffer
        } else {
          sealedData.ciphertextBuffer
        }
        buffer.copiedArray().formatted(outputFormat)
      }
    }
  }

  // region Function implementations

  /**
   * Generates AES-256 key and returns it
   */
  private fun generateKey(size: KeySize?): EncryptionKey {
    return EncryptionKey(size ?: KeySize.AES256)
  }

  @OptIn(EitherType::class, ExperimentalStdlibApi::class)
  private fun importKey(input: Either<ByteArray, String>, encoding: DataEncoding?): EncryptionKey {
    val bytes = if (input.`is`(ByteArray::class)) {
      input.get(ByteArray::class)
    } else {
      requireNotNull(encoding) {
        "'encoding' argument must be provided for string input"
      }
      val encodedString = input.get(String::class)
      when (encoding) {
        DataEncoding.BASE64 -> Base64.decode(encodedString, Base64.DEFAULT)
        DataEncoding.HEX -> encodedString
          .lowercase()
          .substringAfter("0x")
          .hexToByteArray(HexFormat.Default)
      }
    }
    return EncryptionKey(bytes)
  }

  /**
   * Encrypts given [plaintext] with provided key and saves encrypted results
   * (sealed data) into [destination]. After the encryption, the destination
   * array will contain the following, concatenated in order:
   * - IV
   * - Ciphertext with GCM tag
   *
   * @param rawKey AES-256 key bytes. Must be of length [KEY_SIZE]
   * @param plaintext
   */
  private fun encrypt(
    plaintext: ByteArray,
    key: EncryptionKey,
    options: EncryptOptions?,
  ): SealedData {
    val key = key.cryptoKey
    val plaintextBuffer = ByteBuffer.wrap(plaintext)

    val cipher = Cipher.getInstance(CIPHER_TRANSFORMATION_NAME).apply {
      val params = options?.gcmParameterSpec(rng)
      init(Cipher.ENCRYPT_MODE, key, params)
      options?.additionalData?.let { updateAAD(it) }
    }

    return cipher.encrypt(plaintextBuffer)
  }

  /**
   * Decrypts given [sealedData] using provided key and stores decrypted
   * plaintext in the [destination] array.
   *
   * @param rawKey AES-256 key bytes. Must be of length [KEY_SIZE]
   * @param sealedData Typed array consisting of 12-byte IV, followed by
   * actual ciphertext content and ending with 16-byte GCM tag.
   * @return plaintext - should be of ciphertext content length
   */
  private fun decrypt(
    sealedData: SealedData,
    key: EncryptionKey,
    options: DecryptOptions?,
  ): Any {
    val key = key.cryptoKey

    val cipher = Cipher.getInstance(CIPHER_TRANSFORMATION_NAME).apply {
      val spec = GCMParameterSpec(sealedData.tagLength * 8, sealedData.ivBytes)
      init(Cipher.DECRYPT_MODE, key, spec)
    }
    options?.additionalData?.let { cipher.updateAAD(it) }

    val plaintext = cipher.decrypt(sealedData)
    return plaintext.array().formatted(options?.output)
  }

  // endregion
}

// region Exception definitions

private class InvalidKeyLengthException :
  CodedException("The AES key has invalid length")

private class InvalidDataLengthException :
  CodedException("Source or destination array has invalid length")

// endregion

fun ByteArray.base64Encoded(): String =
  Base64.encodeToString(this, Base64.DEFAULT)

fun ByteArray.hexEncoded(): String =
  joinToString("") { "%02x".format(it) }

fun ByteArray.encoded(encoding: DataEncoding): String =
  when (encoding) {
    DataEncoding.HEX -> this.hexEncoded()
    DataEncoding.BASE64 -> this.base64Encoded()
  }

fun ByteArray.formatted(format: OutputFormat?): Any {
  return when (format) {
    OutputFormat.BYTES, null -> this
    OutputFormat.BASE64 -> this.base64Encoded()
  }
}

@OptIn(EitherType::class, ExperimentalContracts::class)
inline fun <reified L: Any, reified R: Any> Either<L, R>?.getType(): KClass<*>? {
  contract { returnsNotNull() implies (this@getType != null) }

  return (if (this == null ) {
      null
  } else if (this.`is`(L::class)) {
      L::class as KClass<*>
  } else {
      R::class as KClass<*>
  })
}

@OptIn(EitherType::class)
sealed class EitherValue<L: Any, R: Any> (protected val either: Either<L, R>) {
  class First<L: Any, R: Any> (either: Either<L, R>): EitherValue<L, R>(either) {
    val value: L
      get() = either.first()
  }
  class Second<L: Any, R: Any> (either: Either<L, R>): EitherValue<L, R>(either) {
    val value: R
      get() = either.second()
  }
}

@OptIn(EitherType::class, ExperimentalContracts::class)
inline fun <reified L: Any, reified R: Any> Either<L, R>?.getSealed(): EitherValue<L, R>? {
  contract { returnsNotNull() implies (this@getSealed != null) }

  if (this == null) {
    return null
  }

  return if (this.`is`(L::class)) {
    EitherValue.First(this)
  } else {
    EitherValue.Second(this)
  }
}